# 线性表的定义
>线性表（List）: 零个或多个数据元素的有限序列

首先它是一个序列。元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。
其次，它是有限的。

a<sub>1</sub>, a<sub>2</sub>,……, a<sub>i-1</sub>, a<sub>i</sub>, a<sub>i+1</sub>,……,a<sub>n</sub>

若将线性表记为(a<sub>1</sub>, a<sub>2</sub>,……, a<sub>i-1</sub>, a<sub>i</sub>, a<sub>i+1</sub>,……,a<sub>n</sub>)，则表中a<sub>i-1</sub>领先于a<sub>i</sub>，a<sub>i</sub>领先于a<sub>i+1</sub>, 称a<sub>i-1</sub>是a<sub>i</sub>的直接前驱元素，a<sub>i+1</sub>是a<sub>i</sub>的直接后继元素。所以线性表元素的个数n(n>=0)定义为线性表的长度，当n=0时，成为空表。

# 线性表的顺序存储结构
>线性表的顺序存储结构，指的是一段地址连续的存储单元的依次存储线性表的数据元素

线性表顺序存储的优点

- 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
- 可以快速地存取表中任一位置的元素

线性表顺序存储的缺点

- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量
- 造成存储空间的“碎片化”

## 数组长度与线性表长度的区别
数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。

线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。

在任意时刻，线性表的长度应该小于等于数组的长度。

    package dataStructure;
	/*
	 * 线性表的顺序存储
	 */

	public class MyArray {
	    private long[] array;   //存储元素的数组
	    private int nElem;      //元素个数
	    private int maxSize;    //数组最大容量
	    public MyArray(int size) {
	        maxSize = size;
	        array = new long[maxSize];
	        nElem = 0;
	    }
	
	    /**
	     * 添加元素
	     * @param value
	     */
	    public void add(long value) {
	        array[nElem] = value;
	        nElem++;
	    }
	
	    /**
	     * 通过索引获取元素
	     * @param index
	     * @return
	     */
	    public long get(int index) {
	        return array[index];
	    }
	
	    /**
	     * 读取数组中所有元素
	     */
	    public void getAll() {
	        for (int i = 0; i < nElem; i++) {
	            System.out.print(array[i] + ",");
	        }
	    }
	
	    /**
	     * 插入元素
	     * @param index
	     * @param value
	     */
	    public void insert(int index, long value) {
	        for (int i = nElem-1; i >= index; i--) {
	            array[i+1] = array[i];
	        }
	        array[index] = value;
	        nElem++;
	    }
	
	    /**
	     * 删除第i个元素
	     * @param index
	     * @return
	     */
	    public long delete(int index) {
	        for (int i = index; i < nElem; i++) {
	            array[i] = array[i+1];
	        }
	        nElem--;
	        return array[index];
	    }
	
	    /**
	     * 是否为空
	     * @return
	     */
	    public boolean isEmpty() {
	        return nElem == 0;
	    }
	
	    /**
	     * 是否已满
	     * @return
	     */
	    public boolean isFull() {
	        return nElem == maxSize;
	    }
	}