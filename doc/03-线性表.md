# 线性表的定义
>线性表（List）: 零个或多个数据元素的有限序列

首先它是一个序列。元素之间是有顺序的，若元素存在多个，则第一个元素无前驱，最后一个元素无后继，其他每个元素都有且只有一个前驱和后继。
其次，它是有限的。

a<sub>1</sub>, a<sub>2</sub>,……, a<sub>i-1</sub>, a<sub>i</sub>, a<sub>i+1</sub>,……,a<sub>n</sub>

若将线性表记为(a<sub>1</sub>, a<sub>2</sub>,……, a<sub>i-1</sub>, a<sub>i</sub>, a<sub>i+1</sub>,……,a<sub>n</sub>)，则表中a<sub>i-1</sub>领先于a<sub>i</sub>，a<sub>i</sub>领先于a<sub>i+1</sub>, 称a<sub>i-1</sub>是a<sub>i</sub>的直接前驱元素，a<sub>i+1</sub>是a<sub>i</sub>的直接后继元素。所以线性表元素的个数n(n>=0)定义为线性表的长度，当n=0时，成为空表。

# 线性表的顺序存储结构
>线性表的顺序存储结构，指的是一段地址连续的存储单元的依次存储线性表的数据元素

线性表顺序存储的优点

- 无须为表示表中元素之间的逻辑关系而增加额外的存储空间
- 可以快速地存取表中任一位置的元素

线性表顺序存储的缺点

- 插入和删除操作需要移动大量元素
- 当线性表长度变化较大时，难以确定存储空间的容量
- 造成存储空间的“碎片化”

## 数组长度与线性表长度的区别
数组的长度是存放线性表的存储空间的长度，存储分配后这个量一般是不变的。

线性表的长度是线性表中数据元素的个数，随着线性表插入和删除操作的进行，这个量是变化的。

在任意时刻，线性表的长度应该小于等于数组的长度。

## 线性表顺序存储的实现

	public class MyArray {
	    private long[] array;   //存储元素的数组
	    private int nElem;      //元素个数
	    private int maxSize;    //数组最大容量
	    public MyArray(int size) {
	        maxSize = size;
	        array = new long[maxSize];
	        nElem = 0;
	    }
	
	    /**
	     * 添加元素
	     * @param value
	     */
	    public void add(long value) {
	        array[nElem] = value;
	        nElem++;
	    }
	
	    /**
	     * 通过索引获取元素
	     * @param index
	     * @return
	     */
	    public long get(int index) {
	        return array[index];
	    }
	
	    /**
	     * 读取数组中所有元素
	     */
	    public void getAll() {
	        for (int i = 0; i < nElem; i++) {
	            System.out.print(array[i] + ",");
	        }
	    }
	
	    /**
	     * 插入元素
	     * @param index
	     * @param value
	     */
	    public void insert(int index, long value) {
	        for (int i = nElem-1; i >= index; i--) {
	            array[i+1] = array[i];
	        }
	        array[index] = value;
	        nElem++;
	    }
	
	    /**
	     * 删除第i个元素
	     * @param index
	     * @return
	     */
	    public long delete(int index) {
	        for (int i = index; i < nElem; i++) {
	            array[i] = array[i+1];
	        }
	        nElem--;
	        return array[index];
	    }
	
	    /**
	     * 是否为空
	     * @return
	     */
	    public boolean isEmpty() {
	        return nElem == 0;
	    }
	
	    /**
	     * 是否已满
	     * @return
	     */
	    public boolean isFull() {
	        return nElem == maxSize;
	    }
	}

# 线性表的链式存储

| 数据域 | 指针域 |
| ------| ------|

数据域存储数据元素信息，指针域存储直接后继位置，两部信息组成数据元素a<sub>i</sub>的存储映像，称为结点。

链表中第一个结点的存储位置叫做头指针。
链表的最后一个结点指针为“空”（通常用“NULL”或者“^”表示）

为了更加便捷地对链表进行操作，会在单链表的第一个结点前附设一个结点，称为头结点。头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。

## 头结点与头指针的异同
头指针：

- 头指针是指链表指向第一个结点的指针，若链表有头结点，则是指向头结点的指针。
- 头指针具有标识作用，所以常用头指针冠以链表的名字。
- 无论链表是否为空，头指针均不为空。头指针是链表的必要元素

头结点

- 头结点是为了操作的统一和方便而设立的，放在第一个元素的结点之前，其数据域一般无意义。
- 有了头结点，对在第一元素结点前插入结点和删除第一结点，其操作与其他结点的操作就统一了
- 头结点不一定是链表必须要素

## 线性表链式存储实现

## 代码
1 "arraylist": 线性表顺序存储
2 "linklist": 线性表的链式存储
3 "doublelinklist": 双向双端表的链式存储
